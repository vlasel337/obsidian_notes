**DynamoDB** – это облачная объектная NoSQL key-value база данных, разработанная компанией Amazon. DynamoDB предназначена для больших высоконагруженных систем.
DynamoDB в иерархии сервисов AWS относится к «tier 0 service», то есть относится к **критически важным (mission-critical)** уровням в экосистеме AWS. 

Ключевые преимущества DynamoDB:
- **Serverless**. Инстансы DynamoDB полностью поддерживаются компанией AWS.
- **Auto-scalable**. DynamoDB умеет автоматически масштабироваться (создавать новые партиции и распределять данные по ним) при высоких нагрузках и в целом может адаптироваться к нагрузке.
- **High availability**. Согласно SLA, DynamoDB гарантирует доступность в 99.99%.
- **AWS environment**. DynamoDB отлично интегрируется с другими сервисами AWS (S3, Lambda и другими).
- **Cost effective model**. DynamoDB предлагает гибкие варианты биллинга при взаимодействии с БД (on-demand/provisioned). 

Особенности DynamoDB:
- Обращение к БД DynamoDB происходит не через SQL-запросы, а по API с авторизацией через IAM.
- В DynamoDB **свой порядок выполнения запросов** отличный от классического порядка выполнения SQL-запросов (например, LIMIT выполняется раньше WHERE).
- По стандартному SLA данные таблицы DynamoDB **реплицируются трижды в трех AZ** (availability zones).
- В таблицах можно устанавливать правила на **TTL (Time-to-Live)** записей, чтобы неактуальные записи автоматически удалялись из таблицы. 
- Базовая консистентность обычных таблиц – eventually consistent. За strong consistency нужно доплачивать. В DynamoDB существует настройка **Global tables**, которая позволяют создавать множественные экземпляры таблицы в разных регионах и автоматически синхронизировать данные между ними (оплачивается отдельно). 
- В DynamoDB существует опция **PITR (Point-In-time-recovery)** для создания бэкапов БД (до 35 дней в прошлое) на случай случайного удаления или перезаписи данных в таблицах (оплачивается отдельно).
- Для таблиц в DynamoDB можно включить **DynamoDB stream**, который позволит отправлять события в потоковый лог изменений (который хранит данные об изменениях в течение 24 часов) при каждом изменении таблицы (оплачивается отдельно). Подключиться к стриму можно по API.
- Для увеличения отзывчивости и уменьшения количества чтений из таблицы к таблице DynamoDB можно добавить кэш через **DAX (DynamoDB accelerator)**.
- DynamoDB **поддерживает ACID транзакции** за отдельную плату (увеличивает стоимость RCU, WCU вдвое).

У БД есть свой Go SDK: https://github.com/zzenonn/dynamodb-simple-inventory.
Также есть документация по работе через Go: https://docs.aws.amazon.com/code-library/latest/ug/go_2_dynamodb_code_examples.html.

При проектировании таблиц DynamoDB необходимо сперва задуматься о юзкейсах по которым будет происходить обращение к таблицам (access patterns): 
- какие данные мы собираемся писать в таблицы,
- какие данные мы собираемся из них  вычитывать.

Ключевые концепты DynamoDB:
- **Таблицы** – это коллекции **записей** (**items**).
- **Записи** – это коллекции **атрибутов** (**attributes**) или key-value пар. Атрибуты могут принадлежать к самым разным типам данных (string, JSON, maps, sets, boolean и др.).
  Максимальный размер записи – 400 KB. Если вес записи превышает 400 KB, нужно использовать S3. Если у нескольких записей наблюдается частое чтение, то они автоматически выделяются в отдельные партиции.
- **Primary_key** записи должен состоять либо из уникального **partition_key**, либо из комбинации глобально уникальных **partition_key + sort_key** (в этом случае partition_key может быть не уникальным).
- **Sort_key** должен задаваться на этапе создания таблицы, в дальнейшем его нельзя будет добавить или изменить без пересоздания таблицы.
- При определении **sort_key** DynamoDB будет хранить данные внутри партиции в отсортированном по **sort_key** виде.

![[DynamoDB table example.png|300]]

Биллинг DynamoDB складывается из:
1. Костов на capacity (RCU / WCU или On-Demand).
2. Костов на хранения данных (записи, атрибуты).
3. Костов на хранение индексов (GSI, LSI).
4. Косты за бэкапы (PITR) и стримы (DynamoDB streaming).
5. Косты на кэшрование через DAX (DynamoDB Accelerator).
6. Косты за использование Global tables.
7. Косты за транзакционные операции.

Возможные операции в DynamoDB:
- Scan – считать всю таблицу целиком за время, зависящее от количества записей в таблице.
- Query – считать записи из какой-то партиции за константное время (гораздо более эффективная операция с точки зрения издержек).
### Индексы (GSI и LSI)
**GSI (Global Secondary Index)** позволяет обращаться к таблице не только по pk, но и по остальным атрибутам. При этом добавление GSI на атрибут, индексирует этот атрибут, то есть обращение к таблице по нему будет достаточно быстрым и при этом не произойдет полного сканирования таблицы. GSI может быть добавлен на таблицу после ее создания. 

По своей сути GSI – это отдельная таблица. Соответственно, создание GSI нужно воспринимать, как создание отдельной копии таблицы.

Существует ограничение на максимальное количество GSI на одной таблице в количестве 20-ти штук. Важно понимать, что если на таблице 20 GSI, и мы пишем в эту таблицу, то мы пишем в нее 20 раз, соответственно и платим двадцатикратно.

Также существует **LSI (Local Secondary Index)**, который включен в косты на чтение и запись и может  быть создан только в момент создания таблицы. LSI всегда привязывается к той же партиции, что и primary_key таблицы, но позволяет выбрать другой sort_key. Количество LSI ограничено 5-ю на 1 таблицу.

По рекомендации чувака из AWS (Lee Hannigan), LSI лучше не использовать (или использовать осторожно) из-за лимитов на вес записи в 400 KB.

### Режимы управления нагрузкой
В DynamoDB есть два основных режима управления издержками за нагрузку:
1. **Provisioned capacity** (ручное управление + авто-скейлинг в рамках установленных границ). Хорошо подходит для предсказуемых и равномерных объемов нагрузки.
2. **On-demand capacity** (автоматическое масштабирование, «плати за использование»).
   Подходит для систем, в которых нагрузка неравномерна, и часто могут случаться пики нагрузки.

При on-demand capacity ресурс на чтение и запись в DynamoDB удваивается по отношению к последнему пику нагрузки. В последствии не нужно платить за неиспользуемый capacity. При provisioned capacity нужно самостоятельно управлять capacity. 

### Паттерны проектирования NoSQL дизайна
Вместо множества реляционных таблиц нужно использовать большие ненормализованные таблицы. 
Разные сущности хранятся в одной таблице: (клиент, адрес, заказ).
Нужно начинать проектирование с одной таблицы.

Основной тип нагрузки в DynamoDB – OLTP. При проектировании важно избегать перегруженных партиций.

Сильно желательно, чтобы partition key был в запросах к DynamoDB.
Хорошей практикой в DynamoDB считается использование **составных sort_key** (status+timestamp). Таким образом мы можем экономить на издержках.






