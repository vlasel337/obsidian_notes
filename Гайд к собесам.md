# Базы данных

## Multi parallel processing

MPP - (multi parallel processing) - параллельное вычисление на нескольких серверах, объединенных в один кластер. 
MPP - распределенная база данных.
Решение подходит для компаний, владеющих очень большими объемами данных.

Запросы подаются на мастер сервер, а он в свою очередь собирает результат из шардов (сегментов кластера, на которых равномерно распределены данные), хранящихся на серверах, объединенных в кластер. Обработка сегментов данных происходит непосредственно на тех серверах, на которых они хранятся.

*Проприетарная система* - софт, который распространяется на платной основе (антипод opensoarce).

DDL - (data definition language) язык определения данных
DML - (data manipulation language) язык манипуляций с данных

## Отличие БД от СУБД

БД (База данных**)** - это организованная коллекция данных хранящаяся и доступная в электронном виде при помощи вычислительных машин.

СУБД (Система Управления Базами Данных) - комплекс программ, позволяющих создать БД и манипулировать данными.

## Вопросы

## 1) В чем отличия dwh от datalake?

«Озера данных», или Data Lake, используют для хранения неформатированных, неструктурированных данных из большого количества внешних источников. Они могут строиться, например, на базе облачного хранилища (S3) и быть дешевле в работе. DWH же предназначены не только для хранения, но и для анализа данных.

DWH разработано для бизнес-целей, поэтому оно хорошо структурировано и легко в понимании и использовании.

Data Lake представляет собой хранилище, где хранятся все необработанные данные в исходном формате без преобразования. Каждый элемент в Data Lake обозначен уникальным идентификатором.

| **Параметр** | DWH | DataLake |
| --- | --- | --- |
| Метод загрузки | ETL | ELT |
| Структурированность | структурированные | неструктурированные |
| select | медленнее | быстрее |
| дороговизна | дороже | дешевле |

## 2) В чем отличия OLAP от OLTP?

OLAP (Online Analytical Processing) - БД, которые служат непосредственно для проведения быстрого анализа больших объемов данных. Обычно такие БД используются на больших предприятиях для построения аналитической отчетности за большой промежуток времени (месяц, квартал, год). Такая информация в основном используется для анализа прошедшего периода и планирования будущего.

OLTP (Online Transaction Processing) (или **реляционные БД)** - это базы данных, основная цель которых - ввод/редактирование/удаление данных в режиме онлайн.

| **Параметр** | **OLAP**  | **OLTP** |
| --- | --- | --- |
| Принцип хранения | денормализация | нормализация |
| insert | сложнее | проще |
| select | быстрее | медленнее |

## 3) В чем отличия архитектуры БД типа “снежинка” (Кимпбелл) от типа “звезда”?

**Звезда:**

Схема звезда лежит в основе реляционного OLAP.

Модель данных состоит из двух типов таблиц: одной таблицы фактов - центр «звезды» - и нескольких таблиц измерений (*dimension table*).

**Снежинка:**

Так же как и в схеме звезды, схема снежинки представлена централизованной таблицей фактов, соединенной с таблицами измерений. Отличием является то, что здесь таблицы измерений нормализованы с рядом других связанных измерительных таблиц, — в то время как в схеме звезды таблицы измерений полностью денормализованы.

## 4) Какие существуют слои данных и зачем они нужны?

1. **Стейджинг (Primary Data Layer)** — уровень, на котором подгружаются данные из внешних источников. Например, из таблиц, ERP-системы или биллинговой системы.
2. **Ядро хранилища (Core Data Layer)** — центральный уровень, который подгоняет данные к единым структурам и ключам. На этом слое обеспечивается целостность и качество данных.
3. **Аналитические витрины (Data Mart Layer)** — слой, который преобразует данные к структурам, удобным для анализа и использования в BI-дашбордах и других аналитических системах.
4. **Сервисный слой (Service Layer)** — уровень, на котором обеспечивается управление предыдущими слоями, мониторинг и диагностика ошибок.

## 5) Какие есть уровни БД?

1. Нижний уровень - уровень, на котором объединяются данные из различных источников.
2. Средний уровень (уровень моделирования) - уровень, на котором преобразуются данные и строится OLAP. На этом уровне обеспечивается целостность данных. 
3. Верхний уровень (клиентский уровень) - уровень из которого клиенты забирают данные из удобных аналитических витрин для построения отчетности.

## 5) Что такое ERP?

Система планирования ресурсов предприятия (ERP) — это программное обеспечение, помогающее предприятиям автоматизировать основные бизнес-процессы и управлять ими для достижения оптимальной производительности.

## 6) Про DataVault и Якорную модель
Выбор подходящей методологии проектирования DWH позволит обеспечить необходимый уровень гибкости и масштабируемости, а также синхронизоваться с поставленными бизнес-задачами.

Если Снежинка и Звезда - это классические методологии проектирования DWH (Waterfall), то DataVault и Якорная модель - в отличии это гибкие методологии проектирования DWH (Agile).

**DataVault**
Позволяет обеспечить параллельную загрузку данных, позволяет масштабироваться без серьезной перестройки.

Состоит из трех категорий сущностей:
1) **Хабы** - бизнес-сущности, например клиент, продукт, заказ. 
   Содержат ключи, ссылки и время добавления/изменения.
2) **Линки** - представление отношений между Хабами в виде таблиц «многие ко многим». Содержат ссылки на суррогатные ключи связанных Хабов.
3) **Сателлиты** - таблицы с контекстными данными (изменяемыми атрибутами сущностей), связанные с Хабами и Линками по принципу «один ко многим».

**Плюсы:** 
- простота доработок - можно независимо разрабатывать и редактировать узлы, привязывать новые сателлиты, менять источники.
**Минусы:**
- высокая нормализация порождает большое кол-во соединений. 
- сложнее поддается пониманию, больший уровень абстракции. 
- большое кол-во объектов повышает затраты на поддержку и документирование.

**Якорная модель**
Эта гибкая методология проектирования подходит для работы с постоянно растущим и меняющимся набором данных.

Состоит из четырех категорий сущностей:
1) **Якорь** - таблица, описывающая сущности или события. 
   Содержит ключи и инфу о времени добавления записи.
2) **Атрибут** - таблица с контекстной информацией об одном атрибуте для Якоря 
   Содержит ссылку на Якорь, значение атрибута и инфу о времени добавления записи. 
3) **Связь** - таблицы для выстраивания связей между Якорями.
4) **Узел** - таблицы, используемые для моделирования общих свойств (состояний).

**Плюсы**: 
- простота доработки хранилища, добавления новых данных и взаимосвязей
- значительная экономия памяти за счет полной нормализации и отсутствия дублей и NULLов.
Минусы:
- Еще сложнее в понимании и поддержке.
- Огромное кол-во объектов усложняет запросы к базе.

## 7) Принципы ACID

**Atomicity** (Атомарность) — гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.

**Consistency** (Согласованность) — транзакция, достигающая своего нормального завершения сохраняет согласованность базы данных. Атомарность гарантирует, что не получится такого, что адрес с телефоном сохранились, а сам клиент — нет. Это сделало бы базу неконсистентной, ведь у нас бы появились атрибуты, «висящие в воздухе», никому не принадлежащие. Что, в свою очередь, приведет к ошибкам в системе.

Разработчик должен настраивать согласованность БД посредством навешивания на таблицы Foreign Key и ограничений (constraint) .

**Isolation** (Изолированность) — во время выполнения транзакции параллельные транзакции не должны создавать конфликтов (потери записей, грязное чтение фантомные данные). Налаживать изолированность можно посредством блокировок таблиц и записей, ограничения редактирования и настройки версионности БД (при каждом обновлении создается новая версия данных и сохраняется старая).

**Durability** (Надёжность) — если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя

## 7) Нормальные формы

**Нормализация** - процесс устранения избыточности данных (чтобы одни и те же данные не хранились в разных местах и не занимали место на диске). Избыточность может привести к аномалиям и рассинхрону: в одном месте данные изменили, а в другом забыли.

| Свойства | Первая НФ                                            | Вторая НФ                                                                       | Третья НФ                                                           |
| -------- | ---------------------------------------------------- | ------------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| 1        | Нет дублирующихся строк                              | Таблица находится в первой НФ                                                   | Таблица находится во второй НФ                                      |
| 2        | Все атрибуты атомарны (в одной ячейке одно значение) | В таблице есть PK                                                               | Неключевые атрибуты зависят только от PK, но не от других атрибутов |
| 3        | Нет посторяющихся атрибутов с одинаковым смыслом     | Все неключевые атрибуты функционально зависят от PK целиком, но не от его части | ———————————                                                         |
- Пример таблицы, не находящейся в 1 НФ (по 2 свойству):

	
	| os      | phone                              |
	| ------- | ---------------------------------- |
	| Android | Google Pixel 6 Pro, Google Pixel 7 |
	| IOS     | Iphone 15                          |
	Атрибут phone не атомарен, так как содержит несколько значений.
	
	| os      | phone1             | phone2         |
	| ------- | ------------------ | -------------- |
	| Android | Google Pixel 6 Pro | Google Pixel 7 |
	| IOS     | Iphone 15          | null           |
	Такой вариант таблицы тоже не удовлетворяет 1 НФ по 3 свойству.
       
- Пример таблицы, не находящейся в 2 НФ (по 3 свойству):
	    
	| phone              | owner | screen_size |
	| ------------------ | ----- | ----------- |
	| Google Pixel 6 Pro | 1     | 6.7         |
	| Google Pixel 7     | 2     | 6.3         |
	| Iphone 15          | 1     | 6.06        |
	    
    PK таблицы - phone + owner. 
    Атрибут screen_size зависит только от части PK, а именно от атрибута phone.
    
- Пример таблицы, не находящейся в 3 НФ (по 2 свойству):
    
	|phone|os|os_maintainer|
	|---|---|---|
	|Google Pixel 6 Pro|Android|Google|
	|Google Pixel 7|Android|Google|
	|Samsung S22|Android|Google|
	|Iphone 15|IOS|Apple|
	    
    Неключевой атрибут os_maintainer зависит от поля os, не являющегося PK. 
    Атрибут os_maintainer зависит от PK phone транзитивно.
    

## 8) Проблема малых файлов в Hadoop

В HDFS данные хранилище разбито на логические единицы - блоки размером 128 mb. 
В HDFS каждый файл хранится в таком блоке, а метаданные блока хранятся в памяти узла имен (NameNode) в виде объекта. Файлы и блоки являются объектами имен и занимают пространство имен.

Это означает, что емкость пространства имен системы ограничена физической памятью узла имен. Примерный размер для хранения каждого такого объекта в пространстве имен равен 150 байт. Поэтому, например, 20 миллионов файлов займут 3 ГБ памяти.

Небольшие файлы HDFS хранит совсем неэффективно: много мелких файлов будут занимать много места на NameNode, хотя сами небольшие файлы не занимают больше места на диске, чем требуется для хранения их содержимого. 

Способы борьбы с проблемой малых файлов:

- Упаковка малых файлов в архив HAR (один большой файл)
- Можно вручную установить размер блока HDFS
- Можно переопределить параметр shuffle.partition