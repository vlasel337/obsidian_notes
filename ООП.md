# ООП

100

## Ключевые понятия (база)

**Класс** - шаблон, описывающий множество объектов имеющих схожую структуру и поведение.
Тип данных и класс — это одно и то же.

**Объект** - сущность, обладающая определенным состоянием (набором атрибутов) и поведением (методами для обращения к его атрибутам). 

Объект созданный на основе класса называется экземпляром класса.

**Интерфейс** – это набор методов класса, доступных для использования другими классами.

## Принципы

**Абстракция** - количество свойств, описывающих объект не должно быть избыточным, оно должно быть таким, чтобы точно передавать суть и предназначение объекта.

Пример: при открытии крана, человеку необязательно знать происхождение воды. Интерфейс стиральной машины.

**Инкапсуляция** - заключение свойств и методов в одном объекте. Заключение свойств внутри объекта позволяет скрывать их от программного кода, находящегося за рамками объекта. Общение программного кода с атрибутами объекта происходит через методы объекта.

**Сокрытие данных** - необходимо для защиты данных от повреждений. 
![[14.jpg]]

**Наследование** - из родительского класса можно создавать дочерние классы путем заимствования атрибутов и методов родительского класса и добавления своих. У одного дочернего класса может быть более одного класса-родителя.

**Полиморфизм** - свойство, которое позволяет использовать один и тот же интерфейс для взаимодействия с объектами разных классов.

Пример 1: операция сложения (’+’) для чисел - это сумма, а для строк - конкатенация.

Пример 2: если человек научился ездить на чепырке, ему будет понятно, как управлять BMW.

## Команды

- Все атрибуты, которыми мы наделяем созданные объекты или классы, хранятся в специальном словаре, который доступен в качестве атрибута **__dict__**
Пример: cat.__dict__
**при использовании атрибута __dict__ к объекту, выведется именно атрибутов объекта, а не класса*

```python
class Cat:
    night_vision = True
    paws_count = 4

print(Cat.__dict__)
#{'__module__': '__main__', 'night_vision': True, 'paws_count': 4, '__dict__': <attribute '__dict__' of 'Cat' objects>, '__weakref__': <attribute '__weakref__' of 'Cat' objects>, '__doc__': None}
```

- При помощи функции **dir()** можно посмотреть список всех атрибутов и методов **объекта**
Пример:

```python
from datetime import date
today = date(2022, 9, 25)
print(dir(today))
```

- При помощи атрибута **__doc__** можно посмотреть описание функции
Пример:

```python
class Cat:
    """Класс, описывающий кошку"""
    night_vision = True
    paws_count = 4

print(Cat.__doc__)
#Класс, описывающий кошку
```

- Команды для взаимодействия с атрибутами объекта

| **Действие** | **Функция** |
| --- | --- |
| Добавление атрибута | setattr(obj, attr, value) |
| Выведение значения атрибута | getattr(obj, attr, <default>) |
| Удаление атрибута ОБЪЕКТА | delattr(obj, attr) |
| Проверка наличия атрибута у объекта | hasattr(obj, attr) |
- Создание класса с инициализатором:

```python
class ElectricCar:
    def __init__(self, color, owner):
        self.color = color
        self.owner = owner
# метод __init__ обязательно должен возвращать None
```

## Методы

- Параметр self (контекстный объект) в объявлении метода экземпляра класса нужен потому что:

```python
class Cat:
    def say(self):
        print('Мяу')
##############################################

cat.say()

# Эквивалентно

Cat.say(cat)
```

- Метод **init**() - метод инициализирующий атрибуты объекта
- Для взаимодействия с защищенными атрибутами извне существуют специальные методы-аксессоры:

| Метод | Предназначение |
| --- | --- |
| Геттеры | для безопасного возвращения значения атрибута |
| Сеттер | для сохранения значение в атрибуте либо изменения значение атрибута (с проверкой на валидность) |
| Делитеры | для удаления атрибута из объекта |

```python
class Cat:
    def __init__(self, name):
        self._name = name                              
# Геттер
    def get_name(self):
		    return self._name
# Сеттер
    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя') 
            # возбуждение исключения - стандартная практика
# Делитер
    def del_name(self):                         
        del self._name                    
```

## Модификаторы доступа

| Тип доступа атрибута | Пример | Описание |
| --- | --- | --- |
| публичный | name | свободны для обращения и изменения |
| защищенный | _name | свободны для обращения и изменения (под ответственность программиста) |
| приватный* | __name | Можно обратиться путем искажения имени при обращении и изменении (_ClassName_ _attribute) |

*Искажение имени приватного атрибута происходит лишь при его установке внутри класса. 

## Фишки

1) Если требуется сделать класс, который на входе будет принимать произвольное кол-во именованных аргументов, это делается так:

```python
class AnyClass:
    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)
```

## Свойства

Свойства - это атрибуты класса (доступные всем экземплярам класса), за которыми закрепляются соответствующие геттеры, сеттеры и делитеры. С ними можно взаимодействовать, как с атрибутами, при этом при взаимодействии с ними неявно вызываются методы (сеттеры и геттеры).

**Зачем нужны?** Свойства нужны для упрощения работы с атрибутами через геттеры, сеттеры и делиттеры. Свойства позволяют создавать методы, которые ведут себя как атрибуты.

Сигнатура функции **property()**, создающей свойства:

```python
property(<fget>, <fset>, <fdelete>, <doc>)

# fget — функция для получения значения атрибута
# fset — функция для установки значения атрибута
# fdel — функция для удаления атрибута
# doc — строка документации
```

Пример создания свойства на основе геттера и сеттера:

```python
class Cat:
    def __init__(self, name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self, name):
        if isinstance(name, str) and name.isalpha():
            self._name = name
        else:
            raise ValueError('Некорректное имя')

    name = property(get_name, set_name)  
```

Пример создания свойства через декораторы:

Когда вставишь? а? а? а?

## Виды методов в ООП

| Метод | С какими атрибутами взаимодействует? | Декоратор | Можно вызывать |
| --- | --- | --- | --- |
| Метод экземпляра класса | Взаимодействует с атрибутами экземпляра класса И с атрибутами класса | - | Можно вызывать через класс без передачи класса и через экземпляр по-хитрому через __class__ |
| Метод класса | Взаимодействует ТОЛЬКО с атрибутами класса | @classmethod | Можно вызывать через экземпляр (без передачи экземпляра) и через класс (с передачей экземпляра) |
| Статический метод | Взаимодействует только с атрибутами, определенными внутри метода | @staticmethod | Можно вызывать и через класс и через экземпляр класса |

## Перегрузка методов

**Дженерики** (универсальные функции) - функции, составленные из нескольких функций, реализующие одну и ту же операцию для разных типов входных данных

**Перегрузка методов** - это приём программирования, который позволяет в зависимости от переданных в метод аргументов использовать определенную версию метода

В Python есть 4 варианта имитации перегрузки (чистой перегрузки нет):

1. Посредством необязательных именованных аргументов
2. Через обработку входных переменных посредством if/elif/else *(антипаттерн)*
3. Через методы класса (@classmethod)
4. Через декоратор **@singledispatchmethod** из библиотеки functools *(хорошая практика)*
*в этом случае нужная реализация метода выбирается на основе типа первого аргумента

Пример перегрузки через **@singledispatchmethod** (похожа на property)

```python
from functools import singledispatchmethod

class MyClass:
    @singledispatchmethod
    def base_implementation(self, arg):
        print('Базовая реализация')

    @base_implementation.register(int)
    def _int_implementation(self, arg):
        print('Реализация для целочисленного аргумента')

    @base_implementation.register(str)
    def _str_implementation(self, arg):
        print('Реализация для строкового аргумента')
       
    @base_implementation.register(tuple) 
    @base_implementation.register(list)
    def _str_implementation(self, arg):
        print('Реализация для списков и кортежей')
```

*названия методов альтернативных реализаций должно отличаться от названия метода базовой реализации

* названия методов альтернативной реализации принято начинать с символа _

## Магические методы (dunders)

1) Метод **__new__**

Метод нужен для создания нового пустого экземпляров класса.

Все классы в python наследуются от базового родительского класса **object** (является родительским для всех классов).

Для того, чтобы можно было создавать экземпляры с атрибутами в метод __new__ передаются *args и **kwargs. Чтобы все работало нормально, они определяются всегда.

```python
class MyClass:
    def __new__(cls, *args, **kwargs):
        instance = object.__new__(cls)

        return instance
```

Метод можно использовать для создания **синглтонов** (объектов, существующих в единственном экземпляре).

```python
class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:                       # при первом вызове создаем объект
            cls._instance = object.__new__(cls)
        return cls._instance                      

first = Singleton() 
second = Singleton()
# переменным присваивается один и тот же объект
```

*Синглтон - паттерн проектирования класса.

2) Методы **__eq__** и **__ne__**

Методы нужны для определения правил равенства (и неравенства) экземпляров класса.

Если в классе не определен метод __eq__(), то сравнение на равенство является сравнением на идентичность.

Методы вызываются при проверки равенства объектов посредством операторов “==”, “in” или при вызове метода непосредственно: print(obj1.__eq__(obj2))

Пример:

```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented # Эквивалент False

    def __ne__(self, other):
        if isinstance(other, Point):
            return self.x != other.x or self.y != other.y
        return True

p1 = Point(1, 2)
p2 = Point(1, 2)
p3 = Point(3, 4)

print(p1 == p2) # True
print(p1 == p3) # False
```

*Если реализован метод **__eq__** , то метод **__ne__** реализуется автоматически.

Константа **NotImplemented** (Эквивалент False) возвращается в случае, если для объектов определенных типов сравнение не предусмотренно. Она нужна для синтаксического сахара.

3) Методы **__gt__**, **__lt__**, **__ge__**, **__le__**

Эти методы нужны для установки правил сравнения объектов класса.

Пример:

```python
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mass

    def __lt__(self, other):
        if isinstance(other, Fruit):
            return self.mass < other.mass
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, Fruit):
            return self.mass > other.mass
        return NotImplemented
	  
	  def __le__(self, other):
        if isinstance(other, Fruit):
            return self.mass <= other.mass
        return NotImplemented

    def __ge__(self, other):
        if isinstance(other, Fruit):
            return self.mass >= other.mass
        return NotImplemented
    

fruit1 = Fruit('банан', 150)
fruit2 = Fruit('яблоко', 180)

print(fruit1 < fruit2) # true
print(fruit1 > fruit2) # false
```

Чтобы избежать лишней писанины, можно использовать декоратор @total_ordering из библиотеки functools. При его использовании можно объявить только 1 метод сравнения, например **__lt__**.

Пример:

```python
from functools import total_ordering

@total_ordering
class Fruit:
    def __init__(self, name, mass):
        self.name = name
        self.mass = mas

    def __lt__(self, other):
        if isinstance(other, Fruit):
            return self.mass < other.mass
        return NotImplemented
```

4) Арифметические операторы **__add__**, **__radd__**, **__iadd__**

Есть три типа арифметических операторов: левые, правые, составного присвоения

```python
class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)

    def __radd__(self, other):
        print('Вызов метода __radd__()')
        return self.__add__(other)
        
    def __iadd__(self, other):
        if isinstance(other, int): # Проверяем на соответствие типа
		        self.coins += other
		        return self # Важно не забывать возвращать
	      else:
			      return NotImplemented

bank = PiggyBank(10)

print(5 + bank)
```

5) Унарные операторы **__pos__**, **__neg__**, **__invert__**, **__round__**, **__floor__**

Унарными называются операторы, которые называются операторы, которые участвуют в операциях с одним операндом: “+”, “-”, “~”

Унарные магические методы обязательно должны возвращать **новый** объект класса, а не изменять старый.

Пример:

```python
class ReversibleString:
    def __init__(self, string):
        self.string = string
        
    def __str__(self):
        return self.string
    
    def __neg__(self):
        return ReversibleString(self.string[::-1])
        
    def __pos__(self):
		    return self.__class__(self.string)

```

6) Метод **__call__**

Метод нужен для того, чтобы экземпляр класса стал вызываемым (с помощью скобок ()) объектом.

Примеры вызываемых объектов: map(), filter()

Пример реализации **__call__**:

```python
class Cat:
    def __init__(self, name):
        self.name = name                   # имя кошки

    def __call__(self):
        print('Меня зовут', self.name)

cat = Cat('Кемаль')

cat()                                      # равнозначно cat.__call__()
```

*Чтобы выяснить является ли объект вызываемым можно использовать функцию callable()

```python
print(callable(int)) # True
```

7) Методы пробразования типов __bool__, __int__, __float__

Методы задают поведение объектов класса при их преобразовании к конкретным типам

```python
class Angle:
    def __init__(self, value):
        self.value = value

    def __int__(self):
        return int(self.value)

    def __float__(self):
        return float(self.value)

angle1 = Angle(100)
angle2 = Angle(100.1)

print(int(angle1)) # 100
print(int(angle2)) # 100
print(float(angle1)) # 100.0
print(float(angle2)) # 100.1
```

8) Методы для взаимодействия с атрибутами объекта **`__getattribute__()`** и **`__getattr__()**, **__setattr__()**, **__delattr__()**`

- `__getattribute__()` — вызывается при обращении к любому атрибуту (вызывается всегда)
- `__getattr__()` — вызывается при обращении к несуществующему атрибуту 
(вызывается в двух случаях:
1) если в теле метода `__getattribute__()` было возбуждено исключение `AttributeError`
2) если метод `__getattr__()` был явно вызван в теле метода `__getattribute__()`)
- `__setattr__()` — вызывается при установке атрибута или изменении его значения
- `__delattr__()` — вызывается при удалении любого атрибута

*удаление и установка атрибутов происходит напрямую через словарь атрибутов `__dict__`

Пример реализации **`__getattribute__()`**

```python
class Cat:
    def __init__(self, name):
        self.name = name                                # имя кошки
        
    def __getattribute__(self, attr):
        print(f'Возвращаю значение атрибута {attr}')
        return object.__getattribute__(self, attr)      # получение значения атрибута attr объекта self

cat = Cat('Кемаль')

print(cat.name)
# Возвращаю значение атрибута name
# Кемаль
```

Пример реализации **`__getattr__()`**

```python
class Cat:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
        
    def __getattr__(self, attr):
        print(f'Возвращаю значение по умолчанию')
        return None
    
    # Можно имитировать наличие атрибутов
    def __getattr__(self, attr):
        if attr == 'info':
            return f'Имя: {self.name}\nПорода: {self.breed}'
        raise AttributeError
```

Пример реализации **`__setattr__()`**

```python
class Cat:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed
    
    def __setattr__(self, attr, value):
        attr = '_' + attr
        self.__dict__[attr] = value
        # object.__setattr__(self, name, value)
        
cat = Cat('Кемаль', 'Британский')
```

* менять значение атрибутов через точечную нотацию (cat.name = “Пушок”) нельзя