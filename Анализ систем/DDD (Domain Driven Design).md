Автор подхода – [[Книги для изучения|Эрик Эванс]].
Книга по DDD: [книга](https://www.oreilly.com/library/view/learning-domain-driven-design/9781098100124/).

В рамках DDD анализ системы базируется на глобальных целях бизнеса. 
В [[Event Storming|Event Storming]] используется другой подход – анализ систем базируется на событиях.
![[DDD vs ES.png|250]]

Основные концепции:
1. **Business domain** – главная цель или проблема бизнеса. Владельцы бизнеса должны определить какую проблему решает их бизнес. Для этого можно использовать [[Модель Остервальдера|Модель Остервальдера]].
2. **Ubiquitous language** (общий язык) – это язык, который используется для описания общей модели бизнеса. Его задача – описывать то, как решаются проблемы бизнеса.
3. **Bounded context** – изолированные контексты, в которых общий язык однозначен.

## Business domain
Домен разбивается на **поддомены** (**subdomains**). Поддомен описывает одну **проблему**, которую решает бизнес. Для определения поддоменов можно выписать департаменты, из которых состоит бизнес, а затем разобраться с тем какую проблему решает каждый из них.

Поддомены нужно называть, исходя из формулировки проблем.

Поддомены могут отличаться друг от друга по:
- **Главному конкурентному преимуществу.** Какой-то функционал поддомена может в отличие от других обладать ключевым конкурентным преимуществом (алгоритм поиска Google).
- **Сложности процессов реализации.** Какой-то функционал требует большого количества ресурсов на разработку (трейдинговый алгоритм, алгоритм поиска Google), другой – минимум (создание личного кабинета, чата с поддержкой).
- **Изменчивости процессов или частоты проверки новых гипотез.** Один функционал может меняться кратно чаще (алгоритм трейдингового бота – несколько раз в неделю), чем другой (форма пополнения баланса – раз в 5 лет).
- **Вариантам реализации**. Ключевой функционал можно делать самостоятельно (скоринг клиентов на выдачу офферов). Сопутствующий функционал заказать у провайдеров (KYC проверки).
- **Интересности решаемой проблемы для работников**. Сложные и интересные задачи решаются разработчиками. Тривиальные задачи отдаются на аутсорс.

Существует 3 основных типа поддоменов:
1. **Core**. В нем заключена основная ценность бизнеса, при этом этот поддомен не обязательно должен быть техническим (для ювелирного магазина – отдел дизайна украшений). Часто core поддомены имеют наивысшую сложность разработки.
2. **Generic**. Отвечает за стандартные проблемы всех компаний (чаще всего для реализации функционала этого поддомена можно заказать готовое решение на рынке).
3. **Supporting**. Помогает основным бизнес процессам, но при этом не несет в себе уникальной ценности.

При определении сложности поддомена нужно учитывать сложность решения проблемы, то есть bounded-context (потому что именно в нем содержится решение).

Чтобы отличить Core и Supporting поддомены есть два мысленных эксперимента:
1. Представить, что разрабатывать поддомен будут джуны или аутсорсеры. Если справятся – Supporting, если нет – Core.
2. Представить, что компания решает отказаться от разработки поддомена и купить готовое решение. Потеряет ли она свою иденичность? Если нет – это Supporting поддомен, если да – Core.

| Вид поддомена  | Есть ли конкурентное преимущество | Сложность реализации                 | Варианты реализации                                    | Изменчивость | Интерес решения проблемы |
| -------------- | --------------------------------- | ------------------------------------ | ------------------------------------------------------ | ------------ | ------------------------ |
| **core**       | да                                | высокая                              | инхаус-разработка                                      | частая       | высокий                  |
| **generic**    | нет                               | может быть как высокой, так и низкой | покупается, аутсорс, no-code, инхаус слабыми командами | редкая       | низкий, есть решения     |
| **supporting** | нет                               | низкая                               | инхаус, аутсорс, no-code                               | редкая       | низкий, есть решения     |
Для разделения поддоменов по типам существует инструмент Core Domain Chart, состоящая из двух осей Сложность (количество условий, валидаций, связей, специфической терминологии) разработки и Ценность для бизнеса:
![[Core Domain Chart HCB.png|450]]
## Ubiquitous language (общий язык) и доменные эксперты
**Доменные эксперты** – люди, разбирающиеся в доменах, их внутренней кухне и терминологии.

Общий язык очерчивает **границы контекстов**. На схемах нужно использовать терминологию, которая используется доменным экспертом.

Если в разных частях системы используются разные термины для одних и тех же сущностей – это подсказка, что это это разные боундед-контексты.

## Bounded context (изолированные контексты)
Для того, чтобы разобраться с терминологией внутри бизнеса нужно разбить бизнес на **изолированные контексты** (bounded-context), в которых терминологический аппарат (общий язык) будет однозначен.
Пример неоднозначности терминов в разных контекстах: 
- лид в маркетинге – потенциальный новый клиент, 
- лид в редакторском контексте – первый абзац статьи.

Поддомен – это про подпроблемы одной большой проблемы, боундед-контексты – это про решения проблем, сформулированных в поддоменах.

Так как поддомен и боундед-контекст – это разные вещи (проблема и решение), они должны назваться по-разному.

Способы определения боундед-контекста:
1. Контексты получаются за счет объединение событий в отдельные группы в процессе Event Storming.
2. Контексты можно получить на основе выделенных бизнес-поддоменов.

Правила для определения изолированного контекста:
-  **1 поддомен = 1 изолированный контекст** (в идеале). Изолированный контекст (bounded context) содержит описание решение проблемы поддомена от доменного эксперта. 
- **1 изолированный контекст == 1 команда разработчиков** (при этом одна команда может работать над разными контекстами). Это нужно для того чтобы не происходило смешения знаний и взаимоисключающих решений.

Если один боундед-контекст не имеет смыла без другого, то их стоит объединить.

Разница между дизайном и архитектурой заключается в том, что архитектура разбирается с областью проблем, а дизайн с областью решений. Архитектура более высокоуровневая, чем дизайн. Поддомены про проблемы, боундед-контексты про решения.

Важные моменты для понимания:
- Generic поддомены необязательно должны быть внешними сервисами. На рынке может не быть готовых решений для проблемы из generic поддомена или они могут оказаться слишком дорогими, тогда их придется сделать самостоятельно.
- Одному поддомену не обязательно должен соответствовать один сервис. Часто могут быть ситуации, когда один поддомен разбивается на несколько сервисов по количеству боундед-контекстов, находящихся внутри поддомена.
- Не имеет смысла выделять отдеклн





