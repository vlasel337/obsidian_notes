Прежде, чем начинать сбор требований к системе, нужно ответить на вопрос **зачем нужна такая система** и какие проблемы она решает. Это позволит пролить свет на часть требований.

При сборе требований важно понимать, что невозможно будет за один заход детально спроектировать функционал по всем освещенным требованиям, поэтому необходимо определиться с **шортлистом базовых требований**, которые должны быть внедрены в первую очередь.
# Функциональные требования
**Функциональные требования** отвечают на вопрос о том, какой функционал (возможности) должна предоставлять пользователям система.

В рамках сбора функциональных требований важно выделить **категории пользователей**, которые будут пользоваться системой (например, водители и пассажиры, арендаторы и лэнлорды, премиалы и экономы).

Также при сборе функциональных требований важно подумать об **интеграции проектируемой системы с внешними системами**.
Например:
- сообщение-кружок из Telegram можно сразу экспортировать в TikTok;
- мессенджер должен уметь переносить контакты из социальной сети;
- сервис такси должен быть интегрирован с картами.

Не стоит забывать о добавлении возможности **оплаты услуг** в функционал сервиса.

При проектировании системы обязательно нужно подумать о **сборе, обработке и хранении данных** (к примеру, сервис поездок должен отправлять информацию об ивентах внутри приложения в сервис аналитики).

Другие популярные функции, которые можно внедрить во множество серсвисов:
- **Отправка уведомлений** - также популярная функция, которая может пригодиться многим сервисам.
- **Разграничение прав доступа** также можно отнести к популярному функциональному требованию.
- Добавление **службы поддержки**.
- **Отзывы** и рейтинги, **добавление в избранное**.
- **Создание персонального профиля**, добавление в друзья.
- **Поиск контента** внутри сервиса (фото, люди, посты итд).

Популярной методологией формирования функциональных требований является **User Story**. В рамках нее предлагается описать потребность какого-то субъекта, взаимодействующего с системой по определенному шаблону: 
```text
"Как <тип пользователя>,
я могу использовать <функционал>, 
чтобы <желаемый результат>"
```

# Нефункциональные требования
**Нефункциональные требования** по своей сути - это набор ограничений к функциональным требованиям. Они отвечают на вопрос о том, как должны работать возможности, описанные в функциональных требованиях, насколько надежной и отзывчивой должна быть система. Нефункциональные требования должны быть **измеримыми**.

Хорошим примером нефункциональных требований, которые можно предъявлять к некоторым сервисам, (например, к сервисам облачных хранилищ) являются [[Принципы ACID|требования ACID]].

В рамках сбора нефункциональных требований уточняются вопросы о:
- **надежности** (например, могут ли теряться какие-то данные),
- **быстродействии** и скорости вступления в силу изменений,
- **доступности** системы.

Основные категории качественных требований ("ilities"):
1. **Производительность и масштабируемость**. Тут важно указать какой объем [[Расчёт нагрузки на систему|нагрузки]] должен выдерживать сервис. 
   Например: сервис нотификаций должен выдерживать нагрузку 500 000 RPS.
2. **Отзывчивость**. Эта характеристика формализуется различными метриками производительности, такими как **TTI (time to interact)** - насколько быстро становятся активными элементы в UI, с которыми может взаимодействовать пользователь, **TTFB (time to first byte)** - сколько пользователи ждут загрузки видео в ленте.
3. **Надежность и доступность**. Здесь речь идет о метриках SLA, таких, как **uptime** (процент времени за определенный период, когда система доступна штатно) и **availability**. Так, например, функция поиска такси в сервисе такси должна быть доступна 99% времени в течение года.
4. **Безопасность**. Тут хорошей идеей будет сослаться на какой-то конвенциональный стандарт безопасности (например, OWASP или AWS Security Checklist), а также задуматься о шифровании данных и надежных методах аутентификации.

Примеры влияния нефункциональных требований на систему:
- **Надежность**: сервис по генерации коротких ссылок из длинных гарантирует, что в течение месяца можно будет попадать на ресурс, находящийся по длинной ссылке, через короткую
- **Быстродействие**: смена никнейма в социальной сети может происходить не мгновенно, а в течение дня
- **Доступность**: банковское приложение может быть недоступно какое-то время в связи с проведением технических работ

Согласно [[CAP-теорема|теореме CAP]] (Consistency, Availability, Partitioning), **невозможно одновременно обеспечить в системе высокую доступность, консистентность и при этом поддержку разделения на части**, поэтому в зависимости от требований приходится делать выбор в пользу одних характеристик в ущерб другим.