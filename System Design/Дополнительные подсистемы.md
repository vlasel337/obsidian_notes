Популярные виды подсистем:
- **Ограничители нагрузки**. Нужны на случай, если нагрузка превзойдет ожидания. 
- **Защита** системы в случае целенаправленных атак. 
- Подсистемы **мониторинга** всех составляющих системы. 
- Инструменты для **взаимодействия** с внешними подсистемами. Необходимо логировать все взаимодействия с внешними системами.

## Подсистемы для ограничения нагрузки (rate limiter)
Подсистемы ограничения нагрузки используются, чтобы система не теряла работоспособность в случае всплеска нагрузки из-за случайного совпадения или наоборот целенаправленной DDOS-атаки.

Запросы можно ограничить от конкретной **сущности**:
- ограничить число запросов от конкретного **пользователя**;
- ограничить число запросов от конкретного **устройства** (парсеры);
- ограничить число запросов от конкретного **IP-адреса**.

Большой наплыв запросов может свидетельствовать о **нежелательной активности**:
- перебор паролей;
- перебор данных кредитных кард;
- целенапраленный нагон активности для того, чтобы сервер захлебнулся из-за числа запросов, превышающего максимальный  RPS (DDOS-атака).

**Rate limiter** – специальный модуль для ограничения нагрузки, который можно добавить в систему.

Модуль ограничения нагрузки можно расположить:
1. **В клиентском приложении**. Ненадежный вариант, так как клиент может обходить такого рода блокировки через developer tools или Postman. Можно рассматривать такой способ размещения, как дополнительный. 
2. **Внутри сервиса**. Более надежный вариант, но перегружает сервис лишним функционалом. Осложняет [[Масштабирование систем|масштабирование сервиса]].
3. **Отдельным модулем между клиентским приложением и сервисом**. Независимое расположение модуля позволяет независимо от основного приложения масштабировать и регулировать нагрузку.
![[Rate limiter position.png|500]]

Требования к ограничителю нагрузки:
- Должен иметь возможность **ограничивать количество запросов** N за время T (RPS);
- Должен **учитывать распределенность** системы и нагрузку с разных серверов;
- Должен быть всегда **доступным**, чтобы не нарушать работоспособность системы;
- Не должен ощутимо ухудшать **быстродействие**.

Стандартные алгоритмы имплементации ограничителя нагрузки:
1. **Алгоритм ведра с токенами**. Бакет определенной емкости (емкость определяется допутстимым  RPS) наполняется токенами. При поступлении запросов токены тратятся. Если при поступлении запроса токена в бакете нет, запрос отбрасывается, клиенту возвращается 429 ошибка. Со временем токены восстанавливаются.
2. **Алгоритм протекающего ведра.** То же самое, что и в предыдущем варианте за исключеним того, что запросы, выбравшие токены, отправляются в очередь, из которой вычитываются воркером с определенной частотой (определенным RPS).
3. **Алгоритм с фиксированным окном**. На каждый фиксированный промежуток времени (например, 1 секунда) устанавливается лимит по количеству запросов.
4. **Алгоритм с обновляемым окном**. Время запросов логируется в списке. При поступлении нового запроса старые события вычищаются из списка. Если в логе нет места для нового запроса, пропускаем его и возвращаем ошибку.
5. **Алгоритм со скользящим окном**. Подход аналогичный фиксированному окну с одним улучшением: окно движется по временному интервалу, не позволяя заспамить запросами на границе двух окон.

## Подсистемы для защиты от целенаправленных атак
Для защиты системы от злоумышленников, которые пытаются целенаправленно перегрузить систему существует несколько способов:
- сокрытие частей системы за обратным прокси;
- использование файрвола для ограничения доступа извне.

**Прокси сервер** позволяет скрыть изначальный устройство-источник запроса, с которого был произведен запрос на сервер.

**Обратный прокси сервер** служит для того, чтобы сокрыть информацию о том, какой из серверов системы дал ответ на запрос пользователя. Такой инструмент позволяет скрыть от пользователя детали об устройстве системы.
![[Reverse proxy.png|400]]

**Файрвол** используется для защиты публичных серверов, расположенных в сети Интернет. Они ограничивают доступ к серверам только по определенным портам (например порт 80 в http и 443 в https).

Типы файрволов:
- **Пакетные фильтры** (самый простой подход). Пропускают запросы только с определенными IP, портами, протоколами.
- **Сеансового уровня**. Устанавливают соединение и пропускают пакеты только в рамках него.
- **Инспеткоры состояний** (наиболее продвинутый вариант). Совмещают функционал пакетных фильтров и сеансовых ограничителей.

Также существуют внешние сервисы такие, как Cloudflare, для комплексной защиты системы. Они предлагают и услуги файрвола и ограничители нагрузки и [[Повышение отзывчивости системы#Использование CDN в качестве кэша|CDN]].

## Подсистемы мониторинга
Мониторить показатели системы нужно для того, чтобы понимать:
- распределение времени ответа тех или иных подсервисов;
- распределение и соотношение между успешными ответами и ошибками.

Для того, чтобы собирать статистику о работоспособности системы и ее частей, **необходимо собирать логи**.

Существует две основные парадигмы отслеживания показателей:
- Сервис сам логгирует свои метрики (**push**). 
  Пример системы: Graphite.
- Сбор метрик происходит внешним монитором через API сервиса (**pull**).
  Пример системы: Prometheus.

К сервису сбора метрик можно подключить дэшборд, самым популярным из которых является Grafana.

Обычно сервис логирования устроен таким образом, что в него пишут свою активность и метрики (напрямую или через очередь сообщений) все сервисы системы, отвечающие за бизнес логику, а он в свою очередь складывает данные в колоночную БД (хранилище метрик). Аналитики в свою очередь могут через какой-то аналитический сервис ходить в это хранилище и забирать данные о метриках для дальнейшего анализа.
![[Monitoring service example.png|400]]

## Внешние подсистемы
Взаимодействие со всеми внешними системами необходимо логировать, чтобы была возможность провести расследование в случае, если возникнет какой-то инцидент.

Для взаимодействия с внешними сервисами хорошей практикой является взаимодействие через очереди сообщений. 
