Существует несколько основных способов повышения отзывчивости системы:
- кэширование данных,
- индексирование данных в БД,
- оптимизация сетевого взаимодействия через выбор подходящего протокола.

Так, отзывчивость в абстрактном сервисе:
![[Abstract app.png|500]]
можно повысить следующим образом:
![[App latency decrease.png|500]]

Описание примененных оптимизаций:
1. Между пользователем и сервером можно установить web-кэш, для того, чтобы каждый раз не генерировать HTML страницу целиком.
2. При обращении к БД с пользователями вместо обращения к БД напрямую можно обращаться за недавно запрошенными данными в кэш.
3. При необходимости обращения к исходной БД Profile Service поиск данных ускорит индекс.
4. В случае Upload Service навешивание индекса нецелесообразно, так как чтение из этого сервиса не сильно превышает запись.
5. Для сервиса рекомендаций кэш не нужен, так как он и так обращается к быстрому хранилищу Redis, которое работает в оперативной памяти.
# Кэширование данных
**Кэш** – это быстрое хранилище, которое прихранивает и возвращает ранее запрошенные данные. Кэш позволяет ускорить обращения к данным за счет использования **более быстрых хранилищ** (таких, как [[Расчёт нагрузки на систему#Нагрузка на хранилище|RAM]]). 

Эффективность кэша базируется на предпосылках о том, что:
1. Более вероятно, что новые обращения будут происходить к **недавним** данным.
2. 80% запросов приходится на 20% данных (**правило Парето**).

Кэш может располагаться на любом уровне приложения:
- **На уровне запросов к балансировщику нагрузки**. [[Масштабирование систем#Балансировщик нагрузки (load balancer)|Балансировщик]] может прихранивать адреса web-страниц, к которым ранее происходило обращение.
- **На уровне запросов к FE**. Возвращаем ранее скомпилированные web-страницы.
- **На уровне запросов к BE**. При обращении к сервису данные можно кэшировать для дальнейшего переиспользования в запросах. 
- **На уровне запросов к данным в БД**. Присториваем в RAM и возвращаем ранее запрошенные данные из [[Реляционные БД|реляционной БД]].
![[Cache on different levels.png]]

## Обновление записей в кэше
Существует проблема с тем, что в кэше можно хранить только часть всех данных (~20% по правилу Парето). В этой связи возникает потребность в **обновлении кэша** более актуальными данными и очищении кэша от старых данных, которые дольше всех лежат в кэше. 

Способы обновления записей в кэше:
- **First in First out (FIFO)**. Обновление по принципу **очереди**: те записи, которые раньше попали в кэш, раньше его покидают кэш.
- **First in First out (LIFO)**. Обновление по принципу стэка: кэшируем более старые записи, а новые записи покидают кэш.
- **Least Recently Used (LRU)**. При необходимости освободить место в кэше удаляются записи, к которым не происходило обращение дольше всего.
- **Most Recently Used (MRU)**. При необходимости освободить место в кэше удаляются записи, к которым происходило самое недавнее обращение.
- **Least Frequently Used (LFU)**. Ведется счет обращения к записям за определенный период. Удаляются самые непопулярные.
- **Random Replacement (RR)**. Записи удаляются из кэша случайно.

Оптимальным вариантом считается гибридная схема обновления записей в кэше на основе комбинации способов **Least Recently Used (LRU)** и **Least Frequently Used (LFU)**.
## Инвалидация кэша
**Инвалидация кэша** – это способы борьбы с ситуацией, когда после добавления записи в кэш происходит обновления записи на источнике (например в БД), и запись в кэше перестает быть валидной.

Способы инвалидации кэша:

| Способ             | Описание                                                                                                               | Плюсы                                                                   | Минусы                                                                                                         |
| ------------------ | ---------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| Сквозная запись    | Чтение данных происходит из кэша. Запись данных происходит транзакционно одновременно и в кэш, и на источник.          | **Гарантирована консистентность** данных в кэше и на источник.          | Запись данных **происходит медленнее** из-за усложнения операции.                                              |
| Запись в обход     | Данные записываются сразу в источник. После чего происходит синхронизация популярных записей между источником и кэшом. | Кэш не нагружается записью невостребованных данных.                     | Свежие данные попадут в кэш только после синхронизации, поэтому могут возникнуть ситуации чтения из источника. |
| Реверсивная запись | Данные сперва записываются в кэш, после чего кэш переносит данные в источник.                                          | Ускоряется скорость записи (так как кэш – это более быстрое хранилище). | Есть риск потери данных, не перенесенных в источник из-за провала синхронизации.                               |
## Использование CDN в качестве кэша
**Content Delivery Network (CDN)** – это распределенные хранилища данных, покрывающие различные регионы, которые можно считать отдельным особым видом кэша. 
Примеры: Cloudflare, AWS Cloudfront, Google Cloud CDN, Microsoft Azure.

Инстансы CDN распределены по большинству популярных регионов по всему миру. Они используются в приложениях с часто запрашиваемыми медиафайлами: аудио, фото, видео.
При обращении к файлу сервис проверяет, на каком ближайшем к пользователю сервере находится файл после чего отдает его пользователю. Если же файла нет на сервере поблизости, CDN обратится к центральному серверу.

# Индексирование БД
**Индексирование БД** – это способ ускорения обращения к данным в исходной БД за счет построения индекса.

Популярные методы построения индекса:
- **Бинарный дерево (B-tree)**. По отсортированному дереву значений выполняется бинарный поиск за время log<sub>n</sub>.

Плюсы индексирования:
- **ускорение поиска** записей по ключу в индексе (от O(N) до O(log<sub>n</sub>) в случае бинарного поиска);
- **ускорение выбора необходимого шарда** при [[Масштабирование систем#Распределение данных между хранилищами (партиционирование)|горизонтальном партиционировании]].

Минусы индексирования:
- при обновлении и удалении данных в хранилище также необходимо обновлять индекс, следовательно, **запись замедляется**;

Когда следует использовать индексы:
- Индексы **следует применять**, когда количество операций на чтение превалирует над количеством операций на запись (R ≫ W). 
- Верно и обратное: если количество записей на чтение не сильно превышает количество записей на запись, то индексы использовать не стоит. Не стоит строить индексы по всем подряд полям.

# Создание идентификаторов записей
В распределенных системах остро стоит вопрос с генерацией ID для записей в БД так, чтобы они были:
- линейные,
- упорядоченными по времени,
- масштабируемые.
Варианты решения проблемы генерации ID на различных инстансах БД:

| Способ                                            | Описание                                                                                                                                                                                                                                                          | Плюсы                                                                                                                                             | Минусы                                                                                                                    |
| ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |:------------------------------------------------------------------------------------------------------------------------- |
| Генерация Universally unique identified (UUID)    | UUID – это стандартный 128-битный идентификатор, который содержит в себе временную метку и идентификатор устройства.                                                                                                                                              | 1) Вероятонсть коллизий крайне мала.<br>2) Нет необходимости в координации между UUID на разных инстансах → **проще масштабироваться**.           | UUID 128-битные, а не 64-битные, они не линейны по времени и могут быть нецелочисленными.                                 |
| Использование отдельного сервиса для генерации ID | При необходимости создать новую запись сервис генерирует ID                                                                                                                                                                                                       | 1) Позволяет генерировать **линейные**, **упорядоченные по времени** ID.<br>2) Такой подход **легко масштабируется**.                             | 1) Генератор является **единой точкой отказа**.<br>2) Необходимо задумываться над **избыточностью** и **синхронизацией**. |
| Подход Twitter<br>                                | ID представляет собой 64-битное число, которое содержит в себе:<br>- зарезервированный бит (1)<br>- временную метку (41)<br>- идентификатор датацентра (5)<br>- идентификатор машины в датацентре (5)<br>- последовательный номер миллисекунды по датацентру <br> | 1) Помещается в 64 бита.<br>Все ID упорядочены и независимы.<br>2) Упрощается маршрутизация при доступе к данным (что **повышает отзывчивость**). | ––                                                                                                                        |

# Выбор подходящего протокола соединения
Отзывчивость системы можно повысить не только за счет увеличения отзывчивости при обращении к данным (за счет кэширования и индексирования), но и за счет оптимизации **сетевых соединений**.

Сетевое соединение между клиентом и сервисом устанавливается в момент, когда клиент делает запрос к серверу, на котором находится сервис.

Существует несколько подходов к установке сетевого взаимодействия между клиентом и сервером:
- стандартное HTTP-взаимодействие,
- AJAX-Polling и HTTP-Polling,
- WebSocket
- Server-Sent Events (SSE)
## Стандартное HTTP взаимодействие
Типичное взаимодействие по [[HTTP|HTTP]] между клиентом и сервером работает по следующему алгоритму:
1. Клиент открывает сетевое соединение с сервером.
2. Клиент отправляет запрос на сервер.
3. Сервер подготавливает ответ.
4. Сервер отправляет ответ по ранее открытому соединению.
![[HTTP network interactions.png]]

## Соединение через AJAX-Polling и HTTP-Polling
При обновлении части данных на web-странице без необходимости перерисовывать страницу целиком можно воспользоваться протоколом AJAX Polling, в рамках которого:
1. Клиент постоянно с каким-то коротким интервалом опрашивает сервер об изменениях.
2. При наличии изменений сервер отправляет их клиенту, при отсутствии изменений сервер возвращает пустой ответ.

Минус подхода: трафик забивается излишними соединениями и ответами сервера (по большей части пустыми), следовательно, забивается HTTP-канал.
![[AJAX Polling.png]]

Альтернативой AJAX-Polling является HTTP-Polling в рамках которого не клиент, а сервер управляет отсылкой данных. Клиент в свою очередь просто создает "висящие" запросы (у которых все-таки есть таймаут), на которые дожидается ответа, после чего отправляет новый запрос.

Минус подхода: все еще тратятся ресурсы на лишние соединения.

## Соединение через WebSocket
В рамках взаимодействия через веб-сокет происходят следующие действия:
- Между клиентом и сервером устанавливается **единственное соединение** через специальную процедуру (**handshake**).
- Веб-сокеты предоставляют **долгоиграющее соединение** между клиентом и сервером.
- Клиент и сервер могут обмениваться данными **в произвольном порядке**.
- Коммуникация обеспечивается с **минимальными задержками**.

По веб-сокету может работать, например, чат в онлайн игре.
![[WebSocket interactions.png]]
## Соединение через Server-Sent Events (SSE)
Подход в протоколе SSE похож на протоколы взаимодействия по AJAX/HTTP-Polling и WebSocket. После первичного обновления данных (и первичной установки соединения) клиент **подписывается на обновления** сервера. В отличие от WebSocket по SSE происходит **одностороннее взаимодействие**.

Такое взаимодействие обычно применяется, когда на сайте происходит обновление данных в real-time, например обновление котировок.
![[Server Sent Events (SSE).png]]
