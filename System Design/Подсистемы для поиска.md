**Модуль поиска** является одним из самых популярных дополнительных компонентов при проектировании системы.

Алгоритм поиска может пригодиться в таких популярных сценариях, как:
- автодополнение поискового запроса,
- поиск в тексте слова из словаря или по шаблону,
- поиск по геолокации.

# Реализация алгоритма автодополнения
**Автодополнение** требуется в ситуациях, когда клиент, например, вводит поисковый запрос, и система должна одновременно с вводом предлагать варианты для его продолжения.

Прежде всего в системе необходимо организовать:
- **хранение поисковых запросов** в key-value БД
- и **сбор статистики** по ним.

Самым простым и прямолинейным решением для автодополнения поискового запроса был бы запроc в БД формата:
```sql
SELECT * FROM stats
WHERE query LIKE 'prefix%'
ORDER BY count DESC
LIMIT 5
```
Однако:
- в рамках такого подхода придется делать в БД **отдельный запрос для каждой введенной буквы**,
- придется **каждый раз сканировать** в БД таблицу stats, что займет O(N) или O(logN), если для таблицы построен индекс.

Оптимальным способом реализации данного алгоритма является реализация "**префиксного дерева**" (trie от английского retrieval):
![[Prefix trie 2.png|500]]

Описание префиксного дерева:
- дерево состоит из вершин и ребер между ними, в основании дерева есть корень, которому не соответствует никакая буква;
- все слова начинаются из корня дерева, каждой новой вершине дерева соответствует какая-то буква;
- каждому слову соответствует какой-то путь в дереве,  вершины, которым соответствует конечное слово, называются листьевыми или **терминальными**;
- пути в дереве, по которым **нет разветвлений**, можно подвергать **сжатию**.

Поиск топа слов:
- для определения наиболее релевантных дополнений для введенной последовательности букв проверяются все терминальные вершины из текущего поддерева на предмет популярности;
- для ускорения алгоритма в каждой вершине **хранится список с топом** слов, которые можно составить в рамках этого поддерева, и статистикой по ним;
- при вводе нового слова алгоритм увеличивает значение счетчика статистики по введенному слову на 1 и при необходимости **обновляет топ слов** в списке;
- хранение топов слов в вершинах дерева обеспечивает получение топа за **константное время**.

# Реализация алгоритма текстового поиска
Существует 3 основных сценария поиска слова в тексте:
1. Поиск подстроки.
2. Поиск вхождения по словарю (например, словарь запрещенных слов).
3. Поиск на основе шаблона.

Помимо алгоритмов также существуют готовые поисковые движки, такие как:
- Apache Lucene.
- Elasticsearch (в его основе лежит Apache Lucene).

## Алгоритм поиска подстроки в строке
**Базовая версия алгоритма** работает так, что искомая подстрока (**needle** – строка, которую пытаемся найти) прикладывается к каждому возможному месту в строке (**haystack** – длинная строка). 
![[haystack needle algo.png|300]]
Таким образом в худшем случае сложность алгоритма (поиск иголки в стоге сена) будет: `O(|haystack| x |needle|)`.

Однако, существует способ поиска совпадения не в лоб, а через **префикс-функцию**.

Префикс-функция:

Реализация префикс функции для строки S на Python:
```python
def prefix(s):
    p = [0] * len(s)
    for i in range(1, len(s)):
        k = p[i - 1]
        while k > 0 and s[k] != s[i]:
            k = p[k - 1]
        if s[k] == s[i]:
            k += 1
        p[i] = k
    return p
```


## Алгоритм поиска по словарю

Алгоритм Ахо-Корасик для поиска появления слов из словаря в тексте.
## Алгоритм поиска шаблона в тексте
По-другому алгоритм поиска в тексте подстроки по заданному шаблону называется **задачей неточного поиска** или **wildcard matching**.

Задача неточного поиска решается посредством динамического программирования при помощи матрицы D разрешением S x P, где S – длина строки, а P – длина шаблона. 
![[Fuzzy search matrix.png|500]]
Начинаем из точки (0; 0) и двигаемся по диагонали вправо вверх. Если есть совпадения, ставим 1, если нет – 0. Если в шаблоне есть "\*", то единицы могут распространяться бесконечно вправо.

# Поиск по геоданным
Примерами приложений, в которых может понадобиться поиск по геоданным могут быть: сервис поиска ресторанов, сервис доставки еды, сервис такси.

**Самый простой способ** найти ближайший к пользователю ресторан – сделать sql-запрос:
```sql
SELECT * FROM restaurants 
WHERE 1=1
	AND (latitude BETWEEN 41.7167 – R AND 41.7167 + R) 
	AND (longitude BETWEEN 44.7853 – R AND 44.7853 + R)
```
Берем геолокацию пользователя и подбираем рестораны, которые находятся от него в радиусе R.

Проблемы такого подхода:
- необходимо сканировать всю таблицу с заведениями и их координатами целиком;
- проблематично навесить на данную таблицу индекс, так как индекс получится навесить только на каждое из измерений по отдельности после чего их придется джойнить.

Существуют более оптимальные подходы для геопоиска такие, как:
1. Геохэширование (GeoHash).
2. Квадродерево (QuadTree).
## GeoHash
Для того, чтобы решить эту проблему существует подход GeoHash, в рамках которого:
- можно объединить две координаты и вычислить их хэш,
- карта земного шара разбивается на клетки при этом, чем больше длина адреса точки в битах, тем выше точность адреса.
![[Geohash.png|350]]

Особенности геохэширования:
- Таким образом, если строчки координат будут близки, то и заведения будут близки. Чтобы найти точки поблизости, достаточно, чтобы их префикс совпадал. 
- Обратное неверно – **близкие точки могут иметь сильно отличающиеся хэши** из-за попадания в разные квадраты.
- Именно поэтому при поиске ближайших заведений стоит включать соседние клетки на карте.
- Найти ближайшие места можно простым запросом:
  `SELECT * FROM places WHERE geohash LIKE ‘prefix%'`.
- При необходимости увеличить зону поиска достаточно немного уменьшить префикс на несколько символов (чтобы отдалить масштаб).
- Можно использовать геохэш для кодирования заведений в рамках конкретного места присутствия (например, для города или района крупного города):
  ![[Geohash code.png|200]]
## QuadTree
**Алгоритм квародерева** позволяет решить проблему неравномерного распределения заведений по карте (когда в некоторые квадраты попадает океан, а в другие Нью-Йорк). Суть алгоритма квадродерева сводится к тому, что карта также, как и в геохэше, разбивается на квадраты, но при попадании в квадрат определенного порогового значения заведений он разделяется на более мелкие квадраты.

Особенности использования квадродерева:
- Дерево строится за линейное время.
- Для поиска ближайших точек интереса либо остаемся в листе, либо поднимаемся на уровень выше для расширения зоны поиска.
- Два соседних заведения могут находиться в соседних квадратах (листьях), поэтому при поиске есть смысл брать соседние квадраты, в том числе и соседние по диагонали.
- Весь алгоритм умещается в оперативную память и выполняется стремительно по времени.

Часть несовершенств поиска через QuadTree, связанных с неравномерностью поиска, решает **библиотека H3 от Uber**, в которой карта разбивается не на квадратные клетки, а на гексагональные. 

В свою очередь **библиотека S2 от Google** кодирует все точки на земле одномерными координатами, которые расположены на [[Кривая Гильберта|кривой Гильберта]].






Можно разбить земной шар на квадраты. Распределение будет неравномерное.

GeoHash

Каждйы геоквадрат разбиваем еще на множество квадратов

 QuadTree динамическое разбиение на точки в зависимости от 

Библиотека H3 от Uber с гексагональным покрытием планеты (более равномерное)
Библиотека S2 от Google с одной координатой для каждой точки земли

# Архитектура подсистемы для поиска

